<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì—ì–´ ë¸”ë¡œìš° ì±Œë¦°ì§€</title>
    <!-- Tailwind CSS ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts (Inter) ë¡œë“œ -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* ê¸°ë³¸ í°íŠ¸ ì„¤ì • */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* ìº”ë²„ìŠ¤ ì»¤ì„œ ì„¤ì • */
        canvas {
            cursor: crosshair;
            background-color: #f0fdf4; /* ì—°í•œ ë…¹ìƒ‰ ë°°ê²½ */
            border-radius: 0.5rem; /* ë‘¥ê·¼ ëª¨ì„œë¦¬ */
            border: 2px solid #22c55e; /* ë…¹ìƒ‰ í…Œë‘ë¦¬ */
        }
        /* ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .modal {
            transition: opacity 0.25s ease;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl">
        <h1 class="text-3xl font-bold text-center text-green-700 mb-4">ğŸ’¨ ì—ì–´ ë¸”ë¡œìš° ì±Œë¦°ì§€ ğŸ’¨</h1>
        
        <!-- ê²Œì„ ì •ë³´ UI: íƒ€ì´ë¨¸, ì ìˆ˜, ì‹œì‘ ë²„íŠ¼, í•˜ë“œ ëª¨ë“œ -->
        <div class="flex justify-between items-center bg-white p-4 rounded-lg shadow-md mb-4 gap-4">
            <div>
                <span class="text-lg font-semibold text-gray-700">ë‚¨ì€ ì‹œê°„:</span>
                <span id="timer" class="text-2xl font-bold text-red-600">05:00</span>
            </div>
            
            <!-- â˜… ì¶”ê°€ëœ UI ìš”ì†Œ â˜… -->
            <div class="flex items-center gap-4">
                <button id="startButton" class="bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300">
                    ê²Œì„ ì‹œì‘
                </button>
                <div class="flex items-center">
                    <input type="checkbox" id="hardModeCheckbox" class="mr-2 h-5 w-5 text-purple-600 focus:ring-purple-500 border-gray-300 rounded">
                    <label for="hardModeCheckbox" class="text-lg font-semibold text-purple-700">í•˜ë“œ ëª¨ë“œ ğŸ˜ˆ</label>
                </div>
            </div>
            <!-- â˜… ì¶”ê°€ ë â˜… -->
            
            <div class="text-right">
                <span class="text-lg font-semibold text-gray-700">ì ìˆ˜:</span>
                <span id="score" class="text-2xl font-bold text-blue-600">0</span>
            </div>
        </div>

        <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
        <canvas id="gameCanvas"></canvas>

        <!-- ë„ì›€ë§ -->
        <p class="text-center text-gray-600 mt-2">ë§ˆìš°ìŠ¤ë¥¼ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ë°”ëŒì´ ë¶‘ë‹ˆë‹¤! (ê°€ê¹Œìš¸ìˆ˜ë¡ ê°•í•´ìš”)</p>
    </div>

    <!-- ê²Œì„ ì˜¤ë²„ ëª¨ë‹¬ -->
    <div id="gameOverModal" class="modal fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center opacity-0 pointer-events-none">
        <div class="bg-white p-8 rounded-lg shadow-xl text-center">
            <h2 class="text-3xl font-bold mb-4">ê²Œì„ ì˜¤ë²„!</h2>
            <p class="text-xl mb-2">ìµœì¢… ì ìˆ˜: <span id="finalScore" class="font-bold text-blue-600">0</span>ì </p>
            <p class="text-gray-700 mb-6">5ë¶„ ë™ì•ˆ ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!</p>
            <button id="restartButton" class="bg-green-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-green-700 transition duration-300">
                ë‹¤ì‹œ ì‹œì‘
            </button>
        </div>
    </div>

    <script>
        // --- 1. ê²Œì„ ìš”ì†Œ ë° ì»¨í…ìŠ¤íŠ¸ ì„¤ì • ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI ìš”ì†Œ
        const timerEl = document.getElementById('timer');
        const scoreEl = document.getElementById('score');
        const modalEl = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì • (ë¶€ëª¨ ì»¨í…Œì´ë„ˆì— ë§ì¶¤)
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = 500; // ë†’ì´ ê³ ì •

        // --- 2. ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
        let ball, hole, mouse;
        let score = 0;
        let gameTime = 300; // 5ë¶„ = 300ì´ˆ
        let timerInterval = null;
        let gameLoopId = null;
        let isMouseDown = false;
        let isGameOver = false;
        let isGameRunning = false; // â˜… ì¶”ê°€: ê²Œì„ ì‹¤í–‰ ìƒíƒœ
        
        let obstacles = []; // â˜… ì¶”ê°€: ì¥ì• ë¬¼ ë°°ì—´
        let startButtonEl, hardModeCheckboxEl; // â˜… ì¶”ê°€: UI ìš”ì†Œ ë³€ìˆ˜

        const forces = {
            wind: { x: 0, y: 0, magnitude: 0 },
            friction: { x: 0, y: 0, magnitude: 0 },
            net: { x: 0, y: 0, magnitude: 0 }
        };
        
        // í™”ì‚´í‘œ ì‹œê°í™” ìŠ¤ì¼€ì¼ (í˜ì˜ í¬ê¸°ë¥¼ í™”ì‚´í‘œ ê¸¸ì´ë¡œ ë³€í™˜)
        const FORCE_SCALE = 20;

        // --- 3. ê²Œì„ ê°ì²´ ì •ì˜ ---
        
        // ê³µ(Ball) ê°ì²´
        const Ball = {
            x: 100,
            y: canvas.height / 2,
            radius: 12,
            vx: 0, // ì†ë„ (x)
            vy: 0, // ì†ë„ (y)
            mass: 5,
            color: '#ef4444', // ë¹¨ê°„ìƒ‰
            frictionCoeff: 0.03, // ë§ˆì°° ê³„ìˆ˜ (ê³µê¸° ì €í•­ + ë°”ë‹¥ ë§ˆì°°)

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            },

            update() {
                // ì•Œì§œí˜(Net Force)ì— ì˜í•´ ê°€ì†ë„ ê³„ì‚°
                const ax = forces.net.x / this.mass;
                const ay = forces.net.y / this.mass;

                // ì†ë„ ì—…ë°ì´íŠ¸
                this.vx += ax;
                this.vy += ay;
                
                // ë§ˆì°°ë ¥ ì ìš© (ì†ë„ì— ë¹„ë¡€í•˜ëŠ” ê°ì†)
                this.vx *= (1 - this.frictionCoeff);
                this.vy *= (1 - this.frictionCoeff);

                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                this.x += this.vx;
                this.y += this.vy;

                // â˜… ì¶”ê°€: ì¥ì• ë¬¼ ì¶©ëŒ ì²˜ë¦¬
                obstacles.forEach(obstacle => {
                    // ê³µì˜ ì¤‘ì‹¬ê³¼ ê°€ì¥ ê°€ê¹Œìš´ ì¥ì• ë¬¼ ìœ„ì˜ ì  ì°¾ê¸°
                    let testX = this.x;
                    let testY = this.y;

                    if (this.x < obstacle.x) testX = obstacle.x; // ì™¼ìª½ ëª¨ì„œë¦¬
                    else if (this.x > obstacle.x + obstacle.width) testX = obstacle.x + obstacle.width; // ì˜¤ë¥¸ìª½ ëª¨ì„œë¦¬
                    
                    if (this.y < obstacle.y) testY = obstacle.y; // ìœ„ìª½ ëª¨ì„œë¦¬
                    else if (this.y > obstacle.y + obstacle.height) testY = obstacle.y + obstacle.height; // ì•„ë˜ìª½ ëª¨ì„œë¦¬

                    const dx = this.x - testX;
                    const dy = this.y - testY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // ì¶©ëŒ ê°ì§€
                    if (distance < this.radius) {
                        const overlapX = (this.radius - Math.abs(dx));
                        const overlapY = (this.radius - Math.abs(dy));

                        // ê²¹ì¹˜ëŠ” ë¶€ë¶„ì´ ì ì€ ìª½ìœ¼ë¡œ íŠ•ê²¨ëƒ„ (ê°„ë‹¨í•œ íŒì •)
                        if (overlapX > overlapY) { 
                            // ìœ„/ì•„ë˜ ì¶©ëŒ
                            if (this.y < obstacle.y) this.y = obstacle.y - this.radius; // ìœ„
                            else this.y = obstacle.y + obstacle.height + this.radius; // ì•„ë˜
                            this.vy *= -0.7; // y ì†ë„ ë°˜ì „
                        } else {
                            // ì¢Œ/ìš° ì¶©ëŒ
                            if (this.x < obstacle.x) this.x = obstacle.x - this.radius; // ì¢Œ
                            else this.x = obstacle.x + obstacle.width + this.radius; // ìš°
                            this.vx *= -0.7; // x ì†ë„ ë°˜ì „
                        }
                    }
                });
                // â˜… ì¶”ê°€ ë â˜…

                // ë²½ ì¶©ëŒ ì²˜ë¦¬
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx *= -0.7; // íƒ„ì„± ì¶©ëŒ (ì•½ê°„ì˜ ì—ë„ˆì§€ ì†ì‹¤)
                } else if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx *= -0.7;
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy *= -0.7;
                } else if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy *= -0.7;
                }
            }
        };

        // êµ¬ë©(Hole) ê°ì²´
        const Hole = {
            x: canvas.width - 60,
            y: canvas.height / 2,
            radius: 25,
            color: '#1f2937', // ì–´ë‘ìš´ íšŒìƒ‰

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }
        };

        // ë§ˆìš°ìŠ¤(Mouse) ê°ì²´
        const Mouse = {
            x: 0,
            y: 0
        };

        // --- 4. í˜ ê³„ì‚° ë° ì‹œê°í™” ---

        // ëª¨ë“  í˜ì„ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
        function calculateForces() {
            // 1. ë°”ëŒ í˜ (Wind Force)
            if (isMouseDown) {
                const dx = ball.x - mouse.x;
                const dy = ball.y - mouse.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);

                // ë°”ëŒì˜ ìµœëŒ€ ì„¸ê¸° (ë„ˆë¬´ ê°•í•˜ì§€ ì•Šê²Œ)
                const maxWindStrength = 4; // â˜… ìˆ˜ì •: ìµœëŒ€ ì„¸ê¸° (ê¸°ì¡´ 8ì—ì„œ 4ë¡œ ì¤„ì„)
                // ë°”ëŒ ì„¸ê¸° (ê±°ë¦¬ì— ë°˜ë¹„ë¡€, 300px ê±°ë¦¬ì—ì„œ ê¸°ì¤€ ì„¸ê¸°)
                let strength = (300 * maxWindStrength) / (dist + 150); 
                strength = Math.min(strength, maxWindStrength); // ìµœëŒ€ê°’ ì œí•œ

                if (dist > ball.radius) { // ë§ˆìš°ìŠ¤ê°€ ê³µ ë‚´ë¶€ì— ìˆì§€ ì•Šì„ ë•Œë§Œ
                    forces.wind.x = (dx / dist) * strength;
                    forces.wind.y = (dy / dist) * strength;
                    forces.wind.magnitude = strength;
                } else {
                    forces.wind = { x: 0, y: 0, magnitude: 0 };
                }
            } else {
                forces.wind = { x: 0, y: 0, magnitude: 0 };
            }

            // 2. ë§ˆì°°ë ¥ (Friction Force) - ì—¬ê¸°ì„œëŠ” Ball.update()ì˜ ê°ì†ìœ¼ë¡œ ì²˜ë¦¬í•¨
            // ì‹œê°í™”ë¥¼ ìœ„í•´ ë§ˆì°°ë ¥ ë²¡í„°ë¥¼ ê³„ì‚°
            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > 0.01) {
                // ë§ˆì°°ë ¥ì€ ì†ë„ì™€ ë°˜ëŒ€ ë°©í–¥
                forces.friction.x = -ball.vx * ball.mass * ball.frictionCoeff * 5; // ì‹œê°í™”ë¥¼ ìœ„í•´ ìŠ¤ì¼€ì¼ ì¡°ì •
                forces.friction.y = -ball.vy * ball.mass * ball.frictionCoeff * 5;
                forces.friction.magnitude = Math.sqrt(forces.friction.x * forces.friction.x + forces.friction.y * forces.friction.y);
            } else {
                forces.friction = { x: 0, y: 0, magnitude: 0 };
            }

            // 3. ì•Œì§œí˜ (Net Force)
            // (ì´ ê²Œì„ì—ì„œëŠ” ë°”ëŒì´ ìœ ì¼í•œ 'ì¶”ì§„' ì•Œì§œí˜ì…ë‹ˆë‹¤. ë§ˆì°°ì€ updateì—ì„œ ì†ë„ë¥¼ ê°ì†ì‹œí‚´)
            forces.net.x = forces.wind.x;
            forces.net.y = forces.wind.y;
            forces.net.magnitude = forces.wind.magnitude;
        }

        // í˜ í™”ì‚´í‘œë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
        function drawForces() {
            // 1. ë°”ëŒ í˜ (íŒŒë€ìƒ‰)
            if (forces.wind.magnitude > 0.1) {
                drawArrow(
                    ball.x, ball.y,
                    ball.x + forces.wind.x * FORCE_SCALE,
                    ball.y + forces.wind.y * FORCE_SCALE,
                    '#3b82f6', 3
                );
            }
            
            // 2. ë§ˆì°°ë ¥ (ì£¼í™©ìƒ‰)
            if (forces.friction.magnitude > 0.1 && !isMouseDown) { // ë°”ëŒ ë¶ˆ ë• ë³µì¡í•´ì„œ ìˆ¨ê¹€
                 drawArrow(
                    ball.x, ball.y,
                    ball.x + forces.friction.x * FORCE_SCALE,
                    ball.y + forces.friction.y * FORCE_SCALE,
                    '#f97316', 2
                );
            }

            // 3. ì•Œì§œí˜ (ë¹¨ê°„ìƒ‰) - ì´ ê²Œì„ì—ì„œëŠ” ë°”ëŒ í˜ê³¼ ë™ì¼
            if (forces.net.magnitude > 0.1) {
                drawArrow(
                    ball.x, ball.y,
                    ball.x + forces.net.x * (FORCE_SCALE + 5), // ë” ì˜ë³´ì´ê²Œ ì¡°ê¸ˆ ê¸¸ê²Œ
                    ball.y + forces.net.y * (FORCE_SCALE + 5),
                    '#dc2626', 4 // êµµê²Œ
                );
            }
        }
        
        // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° í—¬í¼ í•¨ìˆ˜
        function drawArrow(fromX, fromY, toX, toY, color, width) {
            const headlen = 10; // í™”ì‚´ì´‰ ê¸¸ì´
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            ctx.save(); // ìƒíƒœ ì €ì¥
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            
            // ì„ 
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();

            // í™”ì‚´ì´‰
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
            
            ctx.restore(); // ìƒíƒœ ë³µêµ¬
        }

        // â˜… ì¶”ê°€: ì¥ì• ë¬¼ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawObstacle(obstacle) {
            ctx.fillStyle = obstacle.color;
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            ctx.strokeStyle = '#4c1d95'; // ì§„í•œ ë³´ë¼ìƒ‰ í…Œë‘ë¦¬
            ctx.lineWidth = 2;
            ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        }

        // â˜… ì¶”ê°€: ì¥ì• ë¬¼ ìƒì„± í•¨ìˆ˜
        function createObstacles(count) {
            obstacles = [];
            const minGap = 120; // ê³µ/êµ¬ë© ì‹œì‘ ìœ„ì¹˜ì—ì„œ ìµœì†Œ ì´ê²© ê±°ë¦¬

            for (let i = 0; i < count; i++) {
                let newObstacle;
                let validSpawn = false;
                
                // ìœ íš¨í•œ ìœ„ì¹˜ì— ìƒì„±ë  ë•Œê¹Œì§€ ë°˜ë³µ
                while (!validSpawn) {
                    const w = Math.random() * 80 + 50; // â˜… ìˆ˜ì •: ë„ˆë¹„ (50~130), ê¸°ì¡´ (30~90)
                    const h = Math.random() * 80 + 50; // â˜… ìˆ˜ì •: ë†’ì´ (50~130), ê¸°ì¡´ (30~90)
                    const x = Math.random() * (canvas.width - w - 40) + 20; // ìº”ë²„ìŠ¤ ë‚´ ëœë¤ x
                    const y = Math.random() * (canvas.height - h - 40) + 20; // ìº”ë²„ìŠ¤ ë‚´ ëœë¤ y
                    
                    // ê³µ ì‹œì‘ ìœ„ì¹˜ì™€ì˜ ê±°ë¦¬
                    const distToBall = Math.sqrt(Math.pow(x + w/2 - ball.x, 2) + Math.pow(y + h/2 - ball.y, 2));
                    // êµ¬ë© ìœ„ì¹˜ì™€ì˜ ê±°ë¦¬
                    const distToHole = Math.sqrt(Math.pow(x + w/2 - hole.x, 2) + Math.pow(y + h/2 - hole.y, 2));

                    // ê³µê³¼ êµ¬ë©ì—ì„œ ì¶©ë¶„íˆ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ìœ íš¨í•œ ìœ„ì¹˜ë¡œ ê°„ì£¼
                    if (distToBall > minGap && distToHole > minGap) {
                        newObstacle = { x: x, y: y, width: w, height: h, color: '#c084fc' }; // ì—°í•œ ë³´ë¼ìƒ‰
                        validSpawn = true;
                    }
                }
                obstacles.push(newObstacle);
            }
        }


        // --- 5. ê²Œì„ ë¡œì§ ---

        // ì¶©ëŒ ë° ë“ì  í™•ì¸
        function checkScoring() {
            const dx = ball.x - hole.x;
            const dy = ball.y - hole.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // ê³µì´ êµ¬ë©ì— ë¹ ì¡Œì„ ë•Œ
            if (distance < hole.radius - ball.radius / 2) {
                score++;
                scoreEl.textContent = score;
                resetBall(); // ê³µê³¼ êµ¬ë© ìœ„ì¹˜ ì¬ì„¤ì •

                // â˜… ìˆ˜ì •: í•˜ë“œ ëª¨ë“œì¼ ë•Œ ë“ì  ì‹œ ì¥ì• ë¬¼ ì¬ìƒì„±
                // resetBall()ì´ í˜¸ì¶œë˜ì–´ êµ¬ë©ì˜ ìƒˆ ìœ„ì¹˜ê°€ í™•ì •ëœ í›„, ì¥ì• ë¬¼ì„ ìƒì„±í•©ë‹ˆë‹¤.
                if (hardModeCheckboxEl.checked) {
                    createObstacles(5);
                }
            }
        }
        
        // ê³µ ìœ„ì¹˜ ì´ˆê¸°í™” (ìƒˆë¡œìš´ êµ¬ë© ìœ„ì¹˜ì™€ í•¨ê»˜)
        function resetBall() {
            ball.x = Math.random() * (canvas.width / 2) + 50; // ì™¼ìª½ ì ˆë°˜ì—ì„œ ëœë¤
            ball.y = Math.random() * (canvas.height - 100) + 50;
            ball.vx = 0;
            ball.vy = 0;
            
            // êµ¬ë© ìœ„ì¹˜ë„ ëœë¤í•˜ê²Œ ë³€ê²½ (ì˜¤ë¥¸ìª½ ì ˆë°˜)
            hole.x = Math.random() * (canvas.width / 2) + (canvas.width / 2) - 30;
            hole.y = Math.random() * (canvas.height - 100) + 50;
        }

        // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        function updateTimer() {
            if (!isGameRunning || isGameOver) return; // â˜… ìˆ˜ì •: isGameRunning ì²´í¬
            
            gameTime--;
            const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const seconds = (gameTime % 60).toString().padStart(2, '0');
            timerEl.textContent = `${minutes}:${seconds}`;

            if (gameTime <= 0) {
                endGame();
            }
        }

        // --- 6. ë©”ì¸ ê²Œì„ ë£¨í”„ ---

        function gameLoop() {
            if (!isGameRunning || isGameOver) return; // â˜… ìˆ˜ì •: isGameRunning ë° isGameOver ì²´í¬

            // 1. ìº”ë²„ìŠ¤ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. ê³„ì‚°
            calculateForces();

            // 3. ì—…ë°ì´íŠ¸
            ball.update();
            checkScoring();

            // 4. ê·¸ë¦¬ê¸°
            hole.draw();
            ball.draw();
            obstacles.forEach(drawObstacle); // â˜… ì¶”ê°€: ì¥ì• ë¬¼ ê·¸ë¦¬ê¸°
            drawForces();

            // 5. ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // --- 7. ê²Œì„ ì‹œì‘/ì¢…ë£Œ ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

        function startGame() {
            // --- â˜… ìˆ˜ì •: ball, hole, mouse ê°ì²´ ì´ˆê¸°í™” â˜… ---
            // Ball, Hole, Mouse í”„ë¡œí† íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
            // ì´ ì½”ë“œê°€ ì—†ìœ¼ë©´ ball, hole, mouseê°€ undefined ìƒíƒœë¡œ ë‚¨ì•„ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.
            ball = Object.create(Ball);
            hole = Object.create(Hole);
            mouse = Object.create(Mouse);
            // --- â˜… ìˆ˜ì • ë ---

            isGameOver = false;
            isGameRunning = true; // â˜… ì¶”ê°€: ê²Œì„ ì‹¤í–‰ ìƒíƒœë¡œ ë³€ê²½
            score = 0;
            gameTime = 300;
            scoreEl.textContent = score;
            timerEl.textContent = '05:00';
            
            modalEl.classList.add('opacity-0', 'pointer-events-none');
            
            resetBall();

            // â˜… ì¶”ê°€: í•˜ë“œ ëª¨ë“œ ì²´í¬ ë° ì¥ì• ë¬¼ ìƒì„±
            if (hardModeCheckboxEl.checked) {
                createObstacles(5); // í•˜ë“œ ëª¨ë“œ: ì¥ì• ë¬¼ 5ê°œ ìƒì„±
            } else {
                obstacles = []; // ë…¸ë©€ ëª¨ë“œ: ì¥ì• ë¬¼ ì—†ìŒ
            }
            
            // â˜… ì¶”ê°€: ë²„íŠ¼ ë¹„í™œì„±í™”
            startButtonEl.disabled = true;
            hardModeCheckboxEl.disabled = true;
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            isGameOver = true;
            isGameRunning = false; // â˜… ì¶”ê°€: ê²Œì„ ì¤‘ì§€ ìƒíƒœë¡œ ë³€ê²½
            if (timerInterval) clearInterval(timerInterval);
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            
            finalScoreEl.textContent = score;
            modalEl.classList.remove('opacity-0', 'pointer-events-none');

            // â˜… ì¶”ê°€: ë²„íŠ¼ í™œì„±í™”
            startButtonEl.disabled = false;
            hardModeCheckboxEl.disabled = false;
        }

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        // â˜…â˜…â˜… ëª¨ë°”ì¼ í„°ì¹˜ ìœ„ì¹˜ ê³„ì‚° í•¨ìˆ˜ ì¶”ê°€ â˜…â˜…â˜…
        function getTouchPos(evt) {
            const rect = canvas.getBoundingClientRect();
            // ì‹±ê¸€ í„°ì¹˜ë§Œ ê°€ì •
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!isGameRunning) return; // â˜… ì¶”ê°€: ê²Œì„ ì‹¤í–‰ ì¤‘ì¼ ë•Œë§Œ
            isMouseDown = true;
            const pos = getMousePos(e);
            mouse.x = pos.x;
            mouse.y = pos.y;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isGameRunning || !isMouseDown) return; // â˜… ìˆ˜ì •: ê²Œì„ ì‹¤í–‰ ë° ë§ˆìš°ìŠ¤ ë‹¤ìš´ ìƒíƒœì¼ ë•Œë§Œ
            const pos = getMousePos(e);
            mouse.x = pos.x;
            mouse.y = pos.y;
        });

        window.addEventListener('mouseup', () => {
            if (!isGameRunning) return; // â˜… ì¶”ê°€: ê²Œì„ ì‹¤í–‰ ì¤‘ì¼ ë•Œë§Œ
            isMouseDown = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            if (!isGameRunning) return; // â˜… ì¶”ê°€: ê²Œì„ ì‹¤í–‰ ì¤‘ì¼ ë•Œë§Œ
            isMouseDown = false;
        });
        
        // â˜…â˜…â˜… ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¶”ê°€ â˜…â˜…â˜…
        
        // touchstart (mousedownê³¼ ë™ì¼)
        canvas.addEventListener('touchstart', (e) => {
            if (!isGameRunning) return;
            // ìº”ë²„ìŠ¤ í„°ì¹˜ ì‹œ í˜ì´ì§€ ìŠ¤í¬ë¡¤ ë“± ê¸°ë³¸ ë™ì‘ ë°©ì§€
            e.preventDefault(); 
            isMouseDown = true; // ë§ˆìš°ìŠ¤ê°€ ëˆŒë¦° ê²ƒê³¼ ë™ì¼í•˜ê²Œ ì²˜ë¦¬
            const pos = getTouchPos(e);
            mouse.x = pos.x;
            mouse.y = pos.y;
        }, { passive: false }); // preventDefault()ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ passive: falseê°€ í•„ìš”

        // touchmove (mousemoveì™€ ë™ì¼)
        canvas.addEventListener('touchmove', (e) => {
            if (!isGameRunning || !isMouseDown) return;
            e.preventDefault();
            const pos = getTouchPos(e);
            mouse.x = pos.x;
            mouse.y = pos.y;
        }, { passive: false });

        // touchend (mouseupê³¼ ë™ì¼)
        canvas.addEventListener('touchend', (e) => {
            if (!isGameRunning) return;
            e.preventDefault();
            isMouseDown = false;
        });
        
        // touchcancel (mouseleave ë˜ëŠ” mouseupê³¼ ë™ì¼)
        canvas.addEventListener('touchcancel', (e) => {
            if (!isGameRunning) return;
            e.preventDefault();
            isMouseDown = false;
        });
        // â˜…â˜…â˜… í„°ì¹˜ ì´ë²¤íŠ¸ ì¶”ê°€ ë â˜…â˜…â˜…


        // ì¬ì‹œì‘ ë²„íŠ¼
        restartButton.addEventListener('click', startGame);
        
        // ì°½ í¬ê¸° ì¡°ì ˆ ì‹œ ìº”ë²„ìŠ¤ ì¬ì„¤ì • (ê°„ë‹¨í•œ ë²„ì „)
        window.addEventListener('resize', () => {
            canvas.width = canvas.parentElement.clientWidth;
            // êµ¬ë© ìœ„ì¹˜ ë“± ì¬ì„¤ì • í•„ìš” (ì—¬ê¸°ì„œëŠ” ê°„ë‹¨íˆ ë¦¬ì…‹)
            // â˜… ìˆ˜ì •: ê²Œì„ì„ ì´ˆê¸° í™”ë©´ìœ¼ë¡œ ë¦¬ì…‹
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            if (timerInterval) clearInterval(timerInterval);
            initializeGame();
        });

        // --- 8. ê²Œì„ ì´ˆê¸° ì‹œì‘ ---
        // â˜… ìˆ˜ì •: startGame() ëŒ€ì‹  initializeGame() í˜¸ì¶œ
        
        function initializeGame() {
            // ê°ì²´ ì´ˆê¸°í™”
            ball = Object.create(Ball);
            hole = Object.create(Hole);
            mouse = Object.create(Mouse);

            // UI ìš”ì†Œ ì—°ê²°
            startButtonEl = document.getElementById('startButton');
            hardModeCheckboxEl = document.getElementById('hardModeCheckbox');
            
            // ì‹œì‘ ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
            startButtonEl.addEventListener('click', startGame);
            
            // ë²„íŠ¼ ìƒíƒœ ì´ˆê¸°í™”
            startButtonEl.disabled = false;
            hardModeCheckboxEl.disabled = false;

            // ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”
            isGameOver = true; // ì‹œì‘ ì „ì—” 'ê²Œì„ ì˜¤ë²„' ìƒíƒœì™€ ìœ ì‚¬
            isGameRunning = false;
            obstacles = [];

            // ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            resetBall(); // ê³µê³¼ êµ¬ë© ìœ„ì¹˜ ì„¤ì •
            hole.draw();
            ball.draw();
            
            // íƒ€ì´ë¨¸/ì ìˆ˜ ì´ˆê¸° í‘œì‹œ
            timerEl.textContent = '05:00';
            scoreEl.textContent = '0';
        }
        
        initializeGame();

    </script>
</body>
</html>